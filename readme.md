# EDM 1.0

## Введение
**EDM (Entity Data Model)** - клиент серверная библиотека, предназначенная для разработки клиент серверных приложений с трехзвенной архитектурой. EDM подойдет Вам если:
- используется **sql** база данных (postgre)
- движком сервера является **Node.js** 
- клиентом - обычный броузер (CHROME, YANDEX и т.д.). 

**EDM** это инструмент для работы с данными, который позволяет:
- описывать модель данных 
- создавать базу данных или делать изменения в существующей по модели данных
- создавать конфигурации - специальные структуры для хранения разного рода настроек и определений
- производить первоначальную загрузку таблиц и конфигураций
- выполнять сценарии над базой данных, создавать хранимые процедуры, функции, просмотры и т.д.
- задействовать в одном проекте несколько баз данных 
- выполнять запросы к базе данных и делать изменения 
- автоматически строить запросы по модели данных
- использовать специальные шаблоны для построения сложных динамических запросов по переданным параметрам
- создавать классы и объекты данных, используя модель данных
- возвращать результаты запроса к базе в виде сложной структуры связанных объекты (любой объект может содержать ссылки на другие объекты или списки связанных объектов)
- передавать с сервера на клиент и обратно сложные структуры данных
- использовать как на клиенте так и на сервере одни и те же объекты данных
- использовать на клиенте стандартные источники данных и во многих случаях отказаться от программирования сервера 
- использовать информацию о модели данных для построения форм, фильтров, отчетов и т.д.
- использовать систему ролей и маркеров доступа, для разграничения доступа к данным
- использовать подсистему логирования
## Точки применения
Ниже приведена схема работы типового приложения с трехзвенной архитектурой, на которой показаны места возможного применения библиотеки.


<div class="mermaid">
sequenceDiagram
    participant C as Клиент
    participant S as Сервер
    participant B as База данных
    participant P as Исходный код
    Note over C,P: Подготовка
    P->>S:Метаданные
    S->>C:Метаданные
    Note over C,P: Динамические страницы
    P->>S:Шаблоны динамических страниц
    S->>C:Динамические страницы
    S->>C:Данные
    B->>S:SQL запросы
    C->>S:Изменения
    S->>B:SQL запросы
    Note over C,P: Статические страницы
    P->>S:Шаблоны статических
    B->>S:SQL запросы
    S->>C:Статические страницы
</div>

#### Места
- клиент - обычно, это "тонкий" клиент, работающий как одностраничное приложение в броузере (CHROME, YANDEX...), но могут быть и любые другие варианты
- сервер - промежуточный сервер, отвечающей за реализацию бизнес логики системы и работающий на движке Node.js 
- база данных - sql ориентированная база данных (postgre, sqllite...)
- исходный код - исходный код системы (скрипты, шаблоны, программы...)

#### Активности
- подготовка - подготовка к работе сервера и клиента
  - метаданные - перед началом работы на сервер и клиенте производится загрузка описания модели данных, конфигураций, настроек, формируются классы для объектов данных
  - синхронизация - частью библиотеки является генератор базы данных, который умеет создавать и выполнять сценарии как для создания новых объектов в базе, так и для изменения существующих без потери данных. Этот процесс называется синхронизацией модели и структуры базы данных. Библиотека EDM насколько это возможно изолирует пользователя от специфики конкретного сервера базы данных. Это позволяет сравнительно легко переходить с одного сервера базы данных на другой, не меняя описания модели (этому помогает и автоматическая генерация запросов к базе данных)
- динамические страницы - под динамической страницей здесь понимается страница броузера с активным содержимым, которая используется для просмотра и правки данных. Сценарий работы следующий, сначала загружается описание(шаблон) страницы, потом данные. После этого пользователь может производить различные манипуляции над данными, в том числе изменять их и сохранять изменения. Возможны следующие точки применения:
  - шаблоны страниц - шаблоны страниц хранятся в исходном коде и "по дороге" к клиенту могут быть изменены в соответствии с параметрами вызова и метанными. Например, если Вы разрабатываете форму для правки справочника, то список полей справочника можно взять из модели данных, там же есть информация о названиях полей и типах данных. В дальнейшем при изменении модели (добавлено новое поле, изменено название...) эти изменения появятся в форме автоматически, без перепрограммирования последней
  - динамические страницы - описание динамических страниц 
  - SQL запросы - для доступа к данным используются SQL запросы. Имея информацию о модели данных, библиотека EDM позволяет автоматически генерить запросы к базе и формировать результат в виде списка сложных объектов, деревьев и т.д., не теряя при этом контроля над производительностью. Запросы на изменения данных также создаются автоматически. Есть разные уровни автоматизации, вплоть до полного отказа от последней для достижения максимальной производительности 
  - данные - основной поток данных идет с сервера на клиент, с клиента на сервер передаются параметры запросов (фильтры, сортировки...) и изменения в данных. Как передавать сложные структуры данных, например объекты имеющие ссылки на другие объекты, деревья, графы и т.д.? Как производить сериализацию и десериализацию данных при передаче? Как использовать такие возможность классов как свойства и методы? Как сохранять изменения? Все эти задачи решает EDM. Из данных полученных в результате выполнения одного или нескольких SQL запросов на сервере формируются EDM объекты, которые могут быть организованы в структуры любой сложности. После этого эта структура сериализуется и отправляется на клиент. На клиенте после дессериализации Вы получаете ровно то что отправили. Библиотека разрешает использование циклических ссылок в объектах и не дублирует одни и те же объект при передаче
  - изменения - EDM почти полностью решает вопрос с отпиской изменений в данных на сервер, достаточно использовать на клиенте объекты EDM и править их свойства, список произведенных изменений будет сформирован автоматически, передан на сервер и отписан в базу 
- статические страницы - статическими страницами считаются страницы не имеющие активного содержимого код которых (HTML) полностью сформирован на сервере. Как правило, это отчеты. Здесь возможны следующие варианты использования:
  - статические страницы - сформированная страница передается на клиент как есть и EDM тут не нужен, возможно использование EDM при передаче параметров
  - SQL запросы - см. динамические страницы
  - шаблоны отчетов - для формирования отчетов, как правило, используются разного рода шаблонизаторы (например pug), которые используя собственно шаблон, данные начитанные в результате выполнения SQL запросов и метаданные, хранящиеся на сервере могут сформировать любой отчет

## Модель данных
Основой EDM является модель данных. Модель данных используется для последующей генерации структуры базы данных и создания классов объектов данных. Каждой таблице базы данных соответствует свой класс.
### Понятия
- модель - единая структура полностью описывающая модель данных проекта. Модель состоит из одной или нескольких схем (пространств имен)
- схема - структура описывающая часть модели и содержащая описания таблиц, конфигураций и сценариев
- таблица - структура описывающая одну таблицу базы данных, кроме генерации структуры базы данных, описание таблицы используется и для генерации соответствующего класса. Кроме полей базы данных описатель таблицы может содержать описание индексов, валидаторов, фильтров и сортировок. Для формирования классов можно дополнительно включать описатели свойств и методов
- конфигурация - описание конфигурации ни чем не отличается от описания таблицы. Для конфигурации так же как и для таблицы создается класс данных. В базе данных для конфигураций ничего не создается. Конфигурации загружаются из специальных файлов при запуске сервера. Таблицы могут иметь ссылки на элементы конфигурации
- файл описания модели - содержит описание одной схемы(пространства имен). Файлов описания может быть много, они могут лежать в одной папке или быть разбросаны по всему проекту. Каждый файл описания модели должен иметь имя следующего вида *myname.model.js* или *myname.cfg.js*, это позволит выделить их среди остальных файлов. Сборщик модели сканирует весь проект, находит файлы описаний и формирует единое описание. Допускается размещать описания одних и тех же схем и таблиц в разных файлах, в этом случае они объединяются в одно описание и могут либо дополнять, либо переопределять друг друга. Сборка модели производится всякий раз при запуске сервера. Кроме описания такой файл может содержать и данные для конфигураций. Файлов конфигураций также может быть много и они так же могут быть раскиданы по всему проекту
- файл настроек - настройки проекта содержатся в одном или нескольких файлах настроек. Каждый файл описания настроек должен иметь имя следующего вида *myname.settings.js*. Сборщик настроек обходит все файлы и сливает их в один объект, который доступен в любом месте проекта, с помощью специальной функции. 
- EDM класс - класс JavaScript, создается по описателю таблицы или конфигурации, наследует от EDMObj
- EDM объект - экземпляр EDM класса, как правило, соответствует одно строке базы данных
- идентификатор объекта (id) - уникальный идентификатор в пределах одного класса, обычно совпадает с id таблицы

### Соглашения

Использование EDM накладывает некоторые ограничения на разрабатываемую базу. В основном эти ограничения носят рекомендательный характер:
- схемы - не все базы данных поддерживают схемы. Например, для postger схемы будут созданы и таблицы будут размещены именно в тех схемах в которых они объявлены, для SQLLite ни каких схем создаваться не будет
- таблицы - имена таблиц должны быть уникальны для всей модели, не должно быть таблиц с одинаковыми именами, даже если они принадлежат к разным схемам
- id - каждая таблица базы данных должна иметь уникальный идентификатор(первичный ключ) - поле id, и называться это поле должно именно так. Тип данных может быть практически любой, но обычно это int или longint. Для конфигураций принятый тип id - string. Для таблиц, не имеющих id, EDM объекты не создаются. С полем id тесным образом связаны процесс автоматической генерации запросов и сохранения изменений, сериализация и десериализация данных
- ссылки - ссылки на другие таблицы это всегда ссылки на их id. Ссылкам не следует давать имя имеющее суффикс Id

### Описание

Ниже приведен пример файла описания модели с данными для конфигураций. Здесь и далее в качестве примера используется небольшое приложение для заметок.

```js
scheme('mnote', 'Заметки', undefined, undefined, [
    table('note', 'Заметка', 'idObj', null, [
        field('title', 'Заголовок', string(255)),
        field('text', 'Описание', string()),
        field('owner', 'Автор', ref('user', 'restrict', true)),
        field('target', 'Назначение', ref('user', 'restrict', false)),
        field('type', 'Тип', ref('noteType', 'none', true, 'NOTE')),
        field('status', 'Статус', ref('noteStatus', 'none', true, 'NEW')),
        field('date', 'Дата создания', datetime(true)),

        method('toString', 'Вернуть как строку', function (o) { return this.title })
    ]),

    cfg('noteStatus', 'Статус', 'cfgObj', null, [
        field('value', 'Значение', string()),
        field('icon', 'Иконка', string()),
        field('color', 'Цвет', string()),
    ]),

    cfg('noteType', 'Тип', 'cfgObj', null, [
        field('value', 'Значение', string()),
        field('icon', 'Иконка', string()),
        field('color', 'Цвет', string()),
    ]),

])

data('noteStatus', {
    NEW: {
        name: 'Новая',
        icon: 'sap-icon://favorite',
    },
    WORK: {
        name: 'В работе',
        icon: 'sap-icon://wrench',
    },
    WAIT: {
        name: 'Отложено',
        icon: 'sap-icon://present',
    },
    OK: {
        name: 'Готово',
        icon: 'sap-icon://accept',
    },
})

data('noteType', {
    NOTE: {
        name: 'Заметка',
        icon: 'sap-icon://notes',
        color: 'Accent1'
    },
    IDEA: {
        name: 'Идея',
        icon: 'sap-icon://lightbulb',
        color: 'Accent7'
    },
    ERR: {
        name: 'Ошибка',
        icon: 'sap-icon://warning',
        color: 'Accent10'
    },
    NEW: {
        name: 'Новость',
        icon: 'sap-icon://feed',
        color: 'Accent6'
    },
})


```

Для описания структуры используется JavaScript, это само по себе в известной мере формализует описание, кроме этого в редакторе мы без дополнительных затрат получаем форматирование и выделение цветом. Каждому понятию соответствует функция с параметрами. Для задания подчиненности во всех функциях последний параметр задает список дочерних элементов. Список понятий(функций) приведен ниже:

- "корень" описателя
  - scheme - схема базы данных 
  - data - данные для загрузки в конфигурацию или таблицу
  - script - сценарий 
- элементы схем
  - table - таблица базы данных
  - cfg - конфигурации 
  - base - базовый описатель, по базовому описателю таблица не строится, но если таблица или конфигурация ссылается на базовый описатель, то она унаследует всю его функциональность
- элементы таблиц и конфигурация
  - field - поле базы данных
  - index - индекс таблицы
  - filter - описатель фильтра
  - order - описатель сортировки
  - vfield - виртуальное поле 
  - method - метод
  - property свойство 
- типы полей
  - id - специальный тип для id
  - guid - глобальный уникальный идентификатор
  - int - целое число 
  - long - длинное целое
  - short - короткое целое
  - byte - байт
  - real - число с плавающей точкой двойной точности
  - float - число с плавающей точкой
  - decimal - десятичное
  - money - деньги
  - date - дата без времени
  - datetime - дата с временем
  - bool - булевское
  - json - JSON
  - jsonb - JSON (упакованный формат)
  - ref - ссылка
  - reflist - список ссылок

### Утилита синхронизации
Синхронизацией модели называется процесс приведения в соответствие описания (модели) и структуры базы данных. Первый раз структура базы создается по описанию, впоследствии при изменении модели (а это всегда происходит в процессе разработки), необходимо вносить соответствующие изменения в структуру, причем по возможности без потери данных, которые уже набрались в базе. Для синхронизации используется либо утилита SYNC, либо соответствующая функциональность в базе. Утилита имеет единственный(необязательный) параметр - путь к корню проекта, для которого производится синхронизация. Последовательность действий при синхронизации приведена ниже:
- чтение настроек проекта - настройки в частности содержат информацию о том какая база данных используется и как к ней подключаться
- чтение и сборка модели данных
- запуск сценариев, выполняемых до синхронизации (pre-scripts)
- получение информации о текущем состоянии базы
- выполнение первого прохода синхронизации (pre). На первом проходе создаются и изменяются схемы, таблицы, поля
- выполнение второго прохода синхронизации (post). На втором проходе добавляются индексы, ссылки, счетчики, удаляются исключенные из модели схемы, таблицы и поля
- запуск сценариев, выполняемых после синхронизации (post-scripts)

Следует отметить, что все действия с базой выполняются под одной транзакцией и в случае возникновения исключений, все изменения откатываются.

Ниже приведено описание таблицы "Заметки", которая создается в базе postgre по ее описанию

```sql
CREATE TABLE "mnote"."note" ( 
  "id" SERIAL,
  "owner" INTEGER NOT NULL,
  "target" INTEGER NULL,
  "type" TEXT NOT NULL DEFAULT 'NOTE'::text ,
  "status" TEXT NOT NULL DEFAULT 'NEW'::text ,
  "title" VARCHAR(255) NOT NULL DEFAULT ''::character varying ,
  "text" TEXT NOT NULL DEFAULT ''::text ,
  "date" TIMESTAMP NOT NULL DEFAULT now() ,
  CONSTRAINT "note_pkey" PRIMARY KEY ("id"),
  CONSTRAINT "REF_mnote_note_owner" FOREIGN KEY ("owner") REFERENCES "maccess"."user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT "REF_mnote_note_target" FOREIGN KEY ("target") REFERENCES "maccess"."user" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX "foreign_index_mnote_note_status" 
ON "mnote"."note" (
  "status" ASC
);
CREATE INDEX "foreign_index_mnote_note_type" 
ON "mnote"."note" (
  "type" ASC
);
CREATE INDEX "foreign_index_mnote_note_target" 
ON "mnote"."note" (
  "target" ASC
);
CREATE INDEX "foreign_index_mnote_note_owner" 
ON "mnote"."note" (
  "owner" ASC
);

```

## Объектная модель
На клиенте и сервере для работы с данными используется одна и та же объектная модель данных.
### EDMObj
Класс EDMObj создается из того же описания, что и соответствущая таблица в базе. Каждый экземпляр класса содержит одну строку таблицы. Для каждого поля таблицы создается свойство класса, и соответственно есть функции get и set для чтения и записи свойств. Сами значения свойств хранятся в скрытой структуре \_values\_. Свойства обеспечивают конвертацию данных в нужный формат (прописанный в модели), отслеживание изменений значений свойств объекта и разрешения ссылок. Кроме полей базы данных, по описателю модели в объект могут быть добавлены дополнительные свойства и методы.

> Следует отметить, что по описанию модели не создается ни каких файлов с описанием классов, любой объект можно создать или получить с помощью "фабрики" классов по имени класса(таблицы). 

Процесс разрешения ссылок это замена id объекта на полноценный EDMObj. Когда объект считывается из базы, то поля ссылок содержать id строк на которые они ссылаются. При обращении к свойству объекта типа ссылка, вместо id возвращен соответствующий объект. 

>Из-за соображений эффективности ни какие ссылки не разрешаются автоматически, ссылка может быть разрешена только для предварительно начитанных объектов.

### EDMData
Класс EDMData является одновременно и фабрикой классов для EDMObj и контейнером(хранилищем для них). Все EDMObj имеют ссылку на свой EDMData. EDMData обладает функциональностью для создания, получения, поиска и манипуляций со "своими" EDMObj. Кроме этого EDMData является еще и поставщиком "соединений" с базой данных. Все операции с базой выполняются через "соединение". 

## Работа на стороне сервера
Типовая последовательность действий контроллера для работы с данными на стороне сервера приведена ниже:
- получение объекта EDMData
- получение соединения
- начитка данных 
- начитка данных для ссылок
- манипуляции с данными (сортировки, группировки, фильтрация, вычисления...)
- возврат результата
- освобождение ресурсов

### Настройки
Файл настроек может хранить любые настройки проекта. Для EDM он должен как минимум содержать описание подключения к одной или нескольким базам данных и соответствий пространств имен и базам данных. Пример настроек приведен ниже:

```js
// Настройки проекта
settings({
    // Приложение
    "app": {
        "name": "MNote", // имя 
        "title": "MNote", // заголовок 
        "subtitle": "Заметки", // подзаголовок 
        "version": 1, // первичный номер версии 
        "subversion": 0, // вторичный номер версии 
        "colorscheme": "def-sap" // имя цветовой схемы 
    },
    // Подклченные базы данных
    "db": {
        "pg": {
            "require": "postgre", // тип БД
            "dbname": "MBuilder40", // имя БД
            "dbhost": "localhost", // сервер БД
            "dbport": "5432", // порт обращения к БД
            "dbuser": "postgres", // пользователь БД
            "dbpass": "918", // пароль БД
            "extensions": {
                "pgcrypto": true // расширения
            }
        }
    },
    // Связывание моделей данных и используемых баз данных
    "models": {
        "*": "pg"
    },
    ...
})
```

В секции "db" описано подключение к одной единственной базе данных. В секции model показано, что все модели подключены к этой базе. Параметр reuire задает имя модуля, в котором реализована функциональность соединения EDM.

### EDMData и текущий пользователь

Чтобы получить объект EDMData, необходимо воспользоваться функцией getEDMData() библиотеки EDM. У этой функции один единственный параметр - текущий пользователь. Это объект с параметрами текущего пользователя, которые, как правило, хранятся в сессии.

```js
    async function app(req, res, url) {
        let edmData = edm.getEDMData(req.user);
```
В проекте должна быть определена модель данных user (см. пример). По параметрам пользователя и модели данных будет создан полноценный объект данных текущий пользователь(edmData.user). Через текущего пользователя проверяются разрешения на доступ и правку данных для разных категорий пользователей. Это является частью дополнительной функциональности EDM. 

### Соединение

Соединение это класс инкапсулирующий всю функциональность работы с базой. Получить соединение можно с помощью метода EDMData - getConnection(). Метод getConnection() имеет четыре параметра:
- имя схемы
- имя класса(таблицы)
- тип доступа
- параметры подключения к базе
  
По первым двум параметрам находятся параметры подключения к базе в настройках проекта (для этого достаточно одного из этих параметров). Если задан тип доступа(чтение/запись), то с помощью подсистемы разделения доступа, проверяется доступ к схеме или таблице. Последний параметр задает параметры соединения с базой напрямую, его следует задавать в крайних случаях, когда невозможно воспользоваться настройками.

> Соединение оптимальным образом использует глобальный пул подключений к базе. Не следует пытаться без крайней нужды оптимизировать этот процесс.

Парным к методу getConnection() является метод free(), который освобождает все ресурсы и возвращает захваченные подключения в пул подключений.

Ниже представлен обзор методов соединения

#### Параметры
Как правило вызов любого метода транслируется в один или несколько запросов к базе данных. Вот основные параметры методов доступа к базе:
 - name - имя класс(таблицы), задает имя основной таблицы к которой производится запрос 
 - sql - шаблон запроса, текст sql запроса возможно с заданными макроподстановками и именованными параметрами. Если шаблон запроса не задан, то он будет создан автоматически средствами автогенерации 
- params - параметры запроса, задают информацию для формирования секции where запроса
- value - простой объект, свойства объекта используются как параметры запроса
- edmObj - EDMObj, свойства объекта используются как параметры запроса

#### Транзакции
Все манипуляции с базой данных могу происходить в рамках транзакции. Имеется стандартный набор функций для работы с транзакциями:
- beginTran()
- commitTran()
- rollbackTran()

Вот пример кода:
```js
        let edmData = edm.getEDMData(req.user);
        let connection=await edmData.getConnection('mnote')
        try {
            await connection.beginTran();
            await connection.update(...);
            await connection.commitTran();
        } 
        catch {
            await connection.rollbackTran();
        }
        await connection.free();
```

> ВНИМАНИЕ!!! Все методы работы с базой являются асинхронными не забывайте про await
  
#### Базовые методы

К базовым относятся методы, которые "не умеют" возвращать результат в виде списка EDMObj:
- **exec(sql, params)** - выполняет запрос, результат не возвращается
- **query(sql, params)** - выполняет запрос, результат - скалярное выражение (первая колонка первой строки)
- **select(name|sql, params)** - результат список объект, так как возвращает драйвер БД
- **insert(name, value)** - создает новую строку в таблице name, поля заполняются значениями и одноименных параметров, параметр id задает id добавляемого элемента и если он найден, то производится update. Если id не задан, то назначается автоматически. Результат - массив из одного добавленного объекта
- **update(name, value)** - изменяет строку в таблице name, поля заполняются значениями и одноименных параметров, параметр id задает id изменяемой строки, результат - массив из одного добавленного объекта
- **delete(name, value)** - удаляет строку в таблице name, параметр id задает id удаляемой строки. Результата нет
- **nextId(name)** - получить следующий id - возвращает следующий уникальный id для заданной таблицы

> ВНИМАНИЕ!!! Методы insert, update, delete не предназначены для проведения массовых операций по условию, используйте exec

#### Запросы объектов

- **selectObj(name|sql, params)** - результат список EDMObj
- **insertObj(name, value)|insertObj(edmObj)** - создает новую строку в таблице name(здесь и далее если name не задан, то определяется по классу объекта), поля заполняются значениями из одноименных свойств, свойство id задает id добавляемого элемента, если запись с таким id ceotcndetn, то производится update. Если id не задан, то назначается автоматически. Результат - массив из одного EDMObj
- **updateObj(name, value)|updateObj(edmObj)** - изменяет строку в таблице name, поля заполняются значениями из одноименных свойств, свойство id задает id изменяемой строки. Результат массив из одного однизмененного объекта
- **deleteObj(name, value)|deleteObj(edmObj)** - удаляет строку в таблице name, свойство id задает id удаляемой строки. Результата нет

#### Сохранение изменений
Изменения объектов могут приходить либо с клиента, либо накапливаться в текущем EDMData при правке начитанных объектов. Изменения это список объектов каждый объект содержит класс объекта, тип операции и значения. При сохранении изменений по этому списку создается sql для правки, который выполняется в рамках одной транзакции. Для сохранения изменений используется метод **saveData()**. Единственный параметр - список изменений, если не задан, то берется из текущего EDMData.

#### Реализация ссылок
Объекты, которые начитываются из базы с помощью selectObj() накапливаются в текущем EDMData. Если эти объекты содержат ссылки, то они не будут реализованы до тех, пор пока в EDMData не попадут объекты на которые есть ссылки. Рассмотрим пример в котором, из базы данных попытаемся прочитать наши заметки. Каждая заметка содержит ссылки на пользователя (target и user) и ссылки на конфигурации (type и status)

```js
    // Вариант 1

    let data = await connection.selectObj('note');

    //Параметры не заданы поэтому считываются все заметки. 
    // Пользователи не начитываются ни как, поэтому ссылки target и user не будут реализованы (содержат undefined). 
    //Для реализации ссылок на конфигурации ни каких дополнительных действий не требуется. 
    //Поля type и status будут содержать ссылки на объекты конфигураций.
```

```js
    // Вариант 2

    let data = await connection.selectObj('note');
    await connection.selectObj('user');

    // Дополнительно к заметкам начитываются все пользователи, которые есть в базе. 
    // Ссылки target и user будут реализованы, но нам не нужны все пользователи, а только те которые пишут заметки. 
```

```js
    // Вариант 3
    
    let data = await connection.selectObj('note');
    await connection.selectObj('user', 'select * from [user] where id in (select target from [note]) or  id in (select user from [note])');
    
    // Теперь лишние пользователи не начитываются, но пришлось написать довольно сложный запрос.
```

```js
    // Вариант 4

    let data = await connection.selectObj('note');
    await connection.addRef();

    // Вместо сложного запроса, для начитки пользователей, используется метод addRef(). 
    // Мы получаем тот же результат, что и варианте 3, но с меньшими затратами. 
```

Метод addRef умеет начитывать в текущий EDMData все объекты по нереализованным прямым ссылкам, которые на момент вызова есть в объектах EDMData. Глубина вложенности ссылок не ограничена. Гарантируется что каждый объект буде считан только один раз и две одинаковые ссылки будут ссылаться на один и тот же объект. Циклические ссылки не приводят к зацикливанию алгоритма.

#### Возвращение результата на клиент
Даже в нашем простом примере мы получили достаточно сложную структуру. Как передать ее на клиент? Для этого необходимо воспользоваться методом prepareData(). Этот метод используется для упрощения и передачи сложных EDM структур на клиент. Код может выглядеть примерно так:

```js
    data = edmData.prepareData(data);
    res.json(data);
```

На клиенте происходит обратный процесс и мы получаем список заметок с реализованными ссылками.


#### Параметры и шаблоны

В большинстве случаев для автоматической генерации запроса к базе данных достаточно просто указать класс объекта и список параметров. Класс объекта задает имя основной таблицы. По параметрам запроса будут сформированы условия отбора. Если для отбора будут указаны поля связанных таблиц, то они будут подключены в секцию from. Существует два способа передачи параметров:
- ассоциированный - объект вида имя = значение
Использование ассоциированного списка предполагает построение запроса с использованием информации из модели данных, поэтому имя параметра это всегда имя поля из главной таблицы или комплексное имя (список имен разделенных точкой), содержащее путь к полю подчиненной таблицы. Имя параметра может быть дополнено модификатором. Модификатор должен быть отделен от имени символом @. Модификаторы используются если нужно изменить стандартное поведение при автоматической генерации на поведение соответствующее заданному модификатору. Допускаются следующие модификаторы:
    - eq: '=',
    - ne: '!=',
    - like: '~*',
    - gt: '>',
    - lt: '<',
    - ge: '>=',
    - le: '<=',

- специальный - массив объектов со следующими свойствами
    - name - имя 
    - label - метка
    - type - тип (тоже что и модификатор в ассоциированном списке)
    - values - массив значений


В обоих случаях значение это либо простое значение, либо массив. Простое значение это строка, число, дата, булевское, объект (строка, разделенная запятыми превращается в массив). 

Если в запрос формируется по классу объекта, то шаблон запроса формируется автоматически по переданным параметрам. Состав секций from и where будет меняться в зависимости от наличия тех или иных параметров. 

Если передается шаблон, то он сможет принять только те параметры, которые так или иначе перечислены в шаблоне. Секции from и where в основном будут соответствовать шаблону. Из секции where будут исключены условия для незаданных параметров.

Ниже приведен пример двух шаблонов sql с разными вариантами подстановки параметров

```sql
    select *
        from 
            [readerBox] "rb"
            left join [station] "s" on "s"."id"="rb"."station"
            left join [road] "r" on "r"."id"="s"."road"
            left join [kil] "k" on "k"."id"="rb"."kil"
            left join [readerMount] "rm" on 
                "rm"."readerBox"="rb"."id" and 
                coalesce("rm"."begTime",cast('1800-01-01' as timestamp))<=cast($inDatele as timestamp) and 
                coalesce("rm"."endTime",cast('9999-12-31' as timestamp))>=cast($inDatege as timestamp)
            left join [reader] "re" on "re"."id"="rm"."reader"
            left join [saiStatus] "ss" on
                "ss"."id"="rb"."id"
        where true 
        and "rb"."id"=$id
        and "r"."id"=$road
        and "s"."id"=$station
        and cast("re"."serial" as varchar(32))=$context or "s"."name"~*$context or cast("s"."code" as varchar(32))=$context or "k"."ip"=$context
        group by "rb"."id"
        order by "road", "station", "adr"

    select d.* from 
         [saiData] d
         left join [readerMount] m on m.id=d."readerMount"
         left join [readerBox] b on b.id=m."readerBox"
         left join [station] s on b.station=s.id
     where
         (
         1=1
         and $in(road->s.road)$
         and $in(station->s.id)$
         and $in(reader->r.id)$
         and $date(date->d.begTime)$
         )
     order by d.id
```

Виды подстановок:
  - таблица - [<имя таблицы>] - расширяется в "схема"."имя таблицы"
  - параметр - $<имя параметра> - расширяется в номер параметра, с одновременным добавлением значения параметра в массив параметров
  - прямая подстановка - $$имя параметра - подставляется значения параметра в одинарных кавычках непосредственно в запрос. Перед постановкой все одинарные кавычки в запросе заменяются на пустую строку. Если передан массив, то подставляется список значений в кавычках через запятую
  - подстановка фильтра - \$<фильтр>(<имя фильтра>-><имя поля> | @<шаблон фильтра>)\$ - для каждой подстановки, вместо имени поля допускается задавать произвольный шаблон. Шаблон должен начинаться с @. Шаблон может содержать встроенный фильтры.

Список фильтров, которые можно использовать
  - like - поиск по подстроке с помощью оператора (~*). Если передано несколько значений, то будет создано несколько like объединенных по or   
  - in - поиск по списку значений с использованием оператора in
  - asis - подстановка значения как есть 
  - date - поиск по интервалу дат
  - interval - по числовому интервалу
  - eq - поиск по списку значений с использованием оператора =
  - curUser - в качестве значения фильтра используется id текущего пользователя
  - order - используется для формирования правил сортировки

## Работа на стороне клиента

После загрузки библиотеки на клиент Вам становится доступна переменная edm, которая содержит ссылки на свойства и методы библиотеки.
Код приведенный ниже создает фабрику классов

```js
this.edmData = edm.getEDMData();

или

this.edmData = new edm.EDMData(edm.user);
```

Для получения данных с сервера Вы можете воспользоваться например методом $.ajax() библиотеки jQuery (или чем то аналогичным). Пример функции загружающий данные с сервера приведен ниже:

```js
loadModel(name, url, params, callback) {
            return $.get(url, params)
                .then(function (data) {

                    // Метод parse фабрики классов из 
                    // входного потока данных содает 
                    // список EDMObj и реализует ссылки
                    data = this.edmData.parse(data);
                    
                    if (callback) {
                        data = callback.call(this, data);
                    }
                    
                    return data;
                }.bind(this))
                .catch(function (data) {
                    if (callback) {
                        data = callback.call(this, undefined, data);
                    }
                    else {
                        this.error(data);
                    }
                }.bind(this));
        }
```

## Установка

### Сервер

Библиотека может быть установлена в любой развернутый проект NODE JS средствами пакетного менеджера npm. 

Вы должны скачать инсталляционный пакет и распаковать его во временную папку. Для установки нужно выполнить следующую команду:

```
npm install <myfolder>/EDM
```

После этого на сервере для обращения к EDM вы может использовать код следующего вида:

```js
const {helpers, utils} = require('edm')
```

2.	Клиент
Библиотека EDM это не только статический код, но и метаданные, конфигурации и классы, которые создаются и загружаются динамически, по модели данных. Поэтому на клиенте не представляется возможным загрузить все, что нужно, просто сославшись на некий статический ресурс. Загрузка EDM на клиент предполагает, использование специально точки входа на сервере для передачи на клиент кода, который устанавливает библиотеку и все дополнительные ресурсы, сформированные динамически. 
Клиентски “скрипт” инициирующий загрузку

```html      
<script src='sys/edm' ></script>
```

Переадресация запроса на обработчик (роутер)

```js
app.use('/sys', require('./routes/sysRouter')());
```

Обработка запроса и возврат результата – клиентской части библиотеки EDM (sysRouter.js)

```js
const express = require('express');
const { edm } = require('edm');

module.exports = function () {
    const router = express.Router();

    // Загрузка EDM
    router.get('/edm', function (req, res, next) {
        res.send(edm.getEDM());
    });

    return router;
}
```


## Примеры и практики

### Тестовый пример

Тестовый пример представляет собой простое приложение для реализации заметок. Вы можете открыть его по [этой ссылке](http://online.m-cti.ru:3800/). Пароль и логин для входа "guest". 

Каждый пользовать может делать заметки, редактировать и просматривать их. Каждая заметка имеет следующие атрибуты:
- заголовок
- текст
- тип (простая заметка, ошибка…)
- статус (новая, в работе, выполнена…)
- ссылку на пользователя, который создал заметку
- ссылку на пользователя, которому предназначается эта заметка
- дату создания

Интерфейс клиентская часть приложения реализован на OpenUI. Для реализации серверной части использовался Express.
Кроме заметок в состав приложения входят дополнительные формы: просмотр модели данных и тестировщик запросов.

Для тестирования работы EDM на клиенте в “критические” места внедрены “точки останова” (оператор debugger). Вы можете перейти в броузере в режим отладки (F12 в CROME) и увидеть, как работает EDM при чтении данных с сервера, при записи изменений и т.д.
Для тестирования сервера можно воспользоваться возможностями тестировщика запросом или скачать исходный код и развернуть приложение у себя.


<script src="https://cdn.rawgit.com/knsv/mermaid/7.0.0/dist/mermaid.min.js"></script>
<link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/knsv/mermaid/7.0.0/dist/mermaid.css">
<script>mermaid.initialize({ startOnLoad: true });</script>